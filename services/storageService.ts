import Dexie, { Table } from 'dexie';
import { Transaction, Budget, RecurringRule, SavingsGoal, Category } from '../types';

// Dexie Database Definition
class SmartExpenseDB extends Dexie {
  transactions!: Table<Transaction, string>;
  budgets!: Table<Budget, string>;
  recurringRules!: Table<RecurringRule, string>;
  savingsGoals!: Table<SavingsGoal, string>;
  categories!: Table<Category, string>;

  constructor() {
    super('SmartExpenseDB');
    
    // Version 4 adds categories
    (this as any).version(4).stores({
      transactions: '++id, date, type, category',
      budgets: '++id, category',
      recurringRules: '++id, type',
      savingsGoals: '++id, deadline',
      categories: '++id, type, name'
    });

    // Version 3 adds savingsGoals
    (this as any).version(3).stores({
      transactions: '++id, date, type, category',
      budgets: '++id, category',
      recurringRules: '++id, type',
      savingsGoals: '++id, deadline'
    });

    // Version 2 adds recurringRules
    (this as any).version(2).stores({
      transactions: '++id, date, type, category',
      budgets: '++id, category',
      recurringRules: '++id, type'
    });
    
    // Version 1 fallback
    (this as any).version(1).stores({
      transactions: '++id, date, type, category',
      budgets: '++id, category'
    });
  }
}

const db = new SmartExpenseDB();

// Storage Service Class
class StorageService {
  // --- Transaction Methods ---

  async addTransaction(transaction: Transaction): Promise<string> {
    const id = await db.transactions.add({
      ...transaction,
      id: transaction.id || crypto.randomUUID()
    });
    return id.toString();
  }

  async updateTransaction(transaction: Transaction): Promise<void> {
    if (!transaction.id) return;
    await db.transactions.put(transaction);
  }

  async getTransactions(): Promise<Transaction[]> {
    return await db.transactions.orderBy('date').reverse().toArray();
  }

  async deleteTransaction(id: string): Promise<void> {
    await db.transactions.delete(id);
  }

  // --- Budget Methods ---

  async getBudgets(): Promise<Budget[]> {
    return await db.budgets.toArray();
  }

  async updateBudget(budget: Budget): Promise<void> {
    const existing = await db.budgets.where('category').equals(budget.category).first();
    if (existing && existing.id) {
      budget.id = existing.id;
    }
    
    if (budget.id) {
      await db.budgets.put(budget);
    } else {
      await db.budgets.add(budget);
    }
  }

  // --- Recurring Rule Methods ---

  async addRecurringRule(rule: RecurringRule): Promise<string> {
    const id = await db.recurringRules.add({
      ...rule,
      id: rule.id || crypto.randomUUID()
    });
    return id.toString();
  }

  async getRecurringRules(): Promise<RecurringRule[]> {
    return await db.recurringRules.toArray();
  }

  async deleteRecurringRule(id: string): Promise<void> {
    await db.recurringRules.delete(id);
  }

  // Process rules: Check if any rule is due, create transaction, update nextDueDate
  async processRecurringRules(): Promise<number> {
    const rules = await this.getRecurringRules();
    const today = new Date();
    let processedCount = 0;

    for (const rule of rules) {
      const dueDate = new Date(rule.nextDueDate);
      
      if (dueDate <= today) {
        // Create the transaction
        await this.addTransaction({
          title: `[Auto] ${rule.title}`,
          amount: rule.amount,
          type: rule.type,
          category: rule.category,
          date: dueDate.toISOString(),
          notes: 'Generated by automation rule'
        });

        // Calculate next date
        const nextDate = new Date(dueDate);
        switch (rule.frequency) {
          case 'daily': nextDate.setDate(nextDate.getDate() + 1); break;
          case 'weekly': nextDate.setDate(nextDate.getDate() + 7); break;
          case 'monthly': nextDate.setMonth(nextDate.getMonth() + 1); break;
          case 'yearly': nextDate.setFullYear(nextDate.getFullYear() + 1); break;
        }

        // Update rule
        await db.recurringRules.put({
          ...rule,
          nextDueDate: nextDate.toISOString(),
          lastProcessed: new Date().toISOString()
        });

        processedCount++;
      }
    }
    return processedCount;
  }

  // --- Savings Goal Methods ---

  async addSavingsGoal(goal: SavingsGoal): Promise<string> {
    const id = await db.savingsGoals.add({
      ...goal,
      id: goal.id || crypto.randomUUID()
    });
    return id.toString();
  }

  async getSavingsGoals(): Promise<SavingsGoal[]> {
    return await db.savingsGoals.toArray();
  }

  async updateSavingsGoal(goal: SavingsGoal): Promise<void> {
    await db.savingsGoals.put(goal);
  }

  async deleteSavingsGoal(id: string): Promise<void> {
    await db.savingsGoals.delete(id);
  }

  // --- Category Methods ---

  async getCategories(): Promise<Category[]> {
    const count = await db.categories.count();
    if (count === 0) {
      await this.seedDefaultCategories();
    }
    return await db.categories.toArray();
  }

  async addCategory(category: Category): Promise<string> {
    const id = await db.categories.add({
      ...category,
      id: category.id || crypto.randomUUID()
    });
    return id.toString();
  }

  async deleteCategory(id: string): Promise<void> {
    await db.categories.delete(id);
  }

  async seedDefaultCategories() {
    const defaults: Category[] = [
      { name: 'Salary', type: 'income', color: '#10b981' },
      { name: 'Freelance', type: 'income', color: '#3b82f6' },
      { name: 'Investment', type: 'income', color: '#8b5cf6' },
      { name: 'Food', type: 'expense', color: '#f59e0b' },
      { name: 'Transport', type: 'expense', color: '#3b82f6' },
      { name: 'Utilities', type: 'expense', color: '#eab308' },
      { name: 'Entertainment', type: 'expense', color: '#ec4899' },
      { name: 'Housing', type: 'expense', color: '#6366f1' },
      { name: 'Health', type: 'expense', color: '#ef4444' },
      { name: 'Shopping', type: 'expense', color: '#14b8a6' },
    ];
    await db.categories.bulkAdd(defaults);
  }

  // --- Analysis & Management Methods ---

  async getFinancialSummary() {
    const transactions = await this.getTransactions();
    const totalIncome = transactions
      .filter(t => t.type === 'income')
      .reduce((acc, curr) => acc + curr.amount, 0);
    const totalExpense = transactions
      .filter(t => t.type === 'expense')
      .reduce((acc, curr) => acc + curr.amount, 0);
    
    return {
      totalIncome,
      totalExpense,
      balance: totalIncome - totalExpense
    };
  }

  async clearAllData() {
    await db.transactions.clear();
    await db.budgets.clear();
    await db.recurringRules.clear();
    await db.savingsGoals.clear();
    await db.categories.clear();
  }

  async importData(jsonData: string) {
    try {
      const data = JSON.parse(jsonData);
      if (data.transactions && Array.isArray(data.transactions)) {
        await db.transactions.bulkPut(data.transactions);
      }
      if (data.budgets && Array.isArray(data.budgets)) {
        await db.budgets.bulkPut(data.budgets);
      }
      return true;
    } catch (e) {
      console.error("Import failed", e);
      return false;
    }
  }
}

export const storageService = new StorageService();